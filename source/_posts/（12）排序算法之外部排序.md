---
title: （12）排序算法之外部排序
date: 2016-04-12 18:24:05
tags: 
- 排序算法
- 外部排序
categories: 排序算法
---
# 1、外部排序 #

处理实际问题的时候，有时需要对大文件内容进行排序，由于计算机内存有限，所以不能够在内存中使用常规的排序算法完成排序，我们需要利用外存即磁盘进行辅助排序，即将能够放入内存的部分文件内容进行排序，形成一个顺串文件，一个大文件会形成多个顺串文件，最终将所有的顺串文件归并完成最终排序。由于归并过程中只需要取出每个顺串文件中最小的数进行比较，所以不需要担心内存不足的问题。
<!-- more -->

由以上内容可以外部排序主要分为两步，一个是生成顺串文件，另一个是归并顺串文件。

由于磁盘IO速度是内存读取速度的几十万倍，所以我们在进行外部排序的时候应当尽可能的减少磁盘的IO次数。文件的归并过程中，每趟归并会进行一次磁盘IO，所以我们要做的是尽可能是减少归并的次数。比如将一个大文件拆分成4个顺串文件，使用2路归并，那么第一趟归并剩余两个顺串，第二趟完成归并，这个过程对每条数据进行了2次磁盘IO。如果我们使用4路归并，那么只需要一次磁盘IO就可以完成归并。

即便使用2路归并，如果文件可以拆分成两个顺串，我们也可以只进行一次磁盘IO就完成归并。所以可以得出结论，要想减少磁盘IO次数，应当尽可能的减少顺串文件的个数，或则尽可能使用多路归并。

**如何减少顺串文件的个数？**一个最简单的方式就是使顺串文件刚好能放入内存中，也就是将大文件按内存大小进行拆分。但是一个更好的办法是利用最小堆，它可以生成接近两倍于内存大小的顺串文件。

**如何优化多路归并？**使用K路归并时，我们在k个数据中找出最小值，普通的算法需要进行k-1次比较，而使用败者树，只需要进行O(logK)次比较。

下面我们依次了解下最小堆、败者树以及结合两者进行k路归并排序。

# 2、最小堆应用 #

我们在堆排序中已经了解过如何使用最大（小）堆完成排序，不懂的可以先看一下堆排序，这里不再解释详细过程，只说明一下，在生成顺串的时候怎么利用最小堆。

假设内存可以存放一个长度为n的数组。
1. 在文件中取n个数放入到数组中。
2. 将数组元素构造成最小堆。
3. 把根节点a0输出到顺串文件（即当前数组的最小值）。
4. 再从文件中读一个数字b，比较a0和b的大小。如果b>a0，则将b放到根节点（b进入堆）；如果b<a0，则将堆的最后一个元素放到根节点，堆长度减少1（b未进入堆，但进入数组）。
5. 在根节点处重新构建堆。
6. 重复步骤3、4、5，直到堆的长度为0。
7. 换一个顺串文件输出，重复步骤1~7。

解释一下上边的算法，首先数组长度为n，所以顺串文件的长度>=n。在不断输出堆中的最小值的同时，我们还将原文件中的数据不断取出，因为输出的顺串文件内容是已排好序的，所以我们新取的元素如果要进入堆，就要大于已经输出的元素，这样才能保证堆输出的元素可以使顺串文件有序的。对于小于堆中最小值的元素，我们会存在数组中，等待生成第二个顺串文件时处理。

对于随机分布的数据，这样生成的顺串文件大小接近2n，这2n个数据包括最初加入到数组中的n个元素，和每次取出根节点后在原文件中取的大于根节点的元素。

可以考虑两种极端情况，一种是除了数组中的n个元素外，省下的元素都是小于n的，那么顺串文件只有n个数；如果省下的元素都是大于n且升序排列的话，那么顺串文件就与原文件大小相同且有序了。

# 3、败者树应用 #

败者树的原理与我们平时分组比赛相类似，一个参赛者小组出线以后，只需要与其他小组出线的参赛者比赛即可决出冠军，而不需要与所有的参赛者都比一遍。

败者树中，父节点用来存放孩子节点比赛之后的败者，而让胜者参加下一轮比赛。败者树种的根节点是败者，需要在根节点之上再增加一个节点来存储胜者。

<img src="http://7xsp5x.com2.z0.glb.clouddn.com/paixusuanfa-11-1.png" >
<img src="http://7xsp5x.com2.z0.glb.clouddn.com/paixusuanfa-11-2.png" >
<img src="http://7xsp5x.com2.z0.glb.clouddn.com/paixusuanfa-11-3.png" >

重构过程中，新进入败者树的元素只需要跟其父节点进行比较，将败者放入父节点，胜者继续往上比较。

<img src="http://7xsp5x.com2.z0.glb.clouddn.com/paixusuanfa-11-4.png" >


# 4、K路归并排序 #

未完待续...