---
title: Java中堆栈
date: 2016-04-13 09:44:22
tags:
- Java
- 堆栈
categories: Java
---

# 1、堆栈概述 #
通俗来讲，栈与堆都是Java用来在RAM中存放数据的地方。堆主要用来存放new创建的对象和数组，栈主要是存储基本类型的变量和对象的引用，与C++不同，Java自动管理栈和堆，程序员不能直接地操作栈或堆。
<!-- more -->

Java的堆是一个运行时数据区，类的对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由GC（垃圾回收）来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的GC机制会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。（注意：这里不包含String，String会在后边讲解。

假设我们定义一个list对象：

```java
List list = new ArrayList();
```

上述语句在内存中执行的过程是：首先在堆中产生了一个ArrayList对象，然后在栈中定义一个特殊的变量list，让栈中这个变量的取值等于ArrayList对象在堆内存中的首地址，栈中的这个变量就成了该ArrayList对象的引用变量。 引用变量就相当于是该对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的对象。

# 2、堆栈中数据的释放 #

引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被GC收走（释放掉）。这也是 Java 比较占内存的原因。
 
实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！

# 3、栈的数据共享 #

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
```java
int a = 3;
int b = 3;
```

编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。

这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。

# 4、String类的处理方式 #

String是一个特殊的包装类数据。可以用：

```java
String str = new String("abc"); 
String str = "abc";
```

两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放"abc"，如果没有，则将"abc"存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。

比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。

```java
String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2); //true
```

可以看出str1和str2是指向同一个对象的。

```java
String str1 =new String ("abc");
String str2 =new String ("abc");
System.out.println(str1==str2); // false 
```

用new的方式是生成不同的对象。每一次生成一个。只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！

因此用第二种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。

另一方面, 要注意: 我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。

补充一点:

关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：
1. 先定义一个名为str的对String类的对象引用变量：String str；
2. 在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并将o的字符 串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o；如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。
3. 将str指向对象o的地址。
事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这 个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。所以操作字符串的时候，还是建议使用StringBuffer。

# 5、包装类一点特殊的地方 #

这里不是讲堆栈的问题，只是一个小知识点顺便记录下来。

请先看下边的例子：

```java
Integer i1 = new Integer(3);
Integer i2 = new Integer(3);
System.out.println(i1 == i2);//false
Integer i3 = new Integer(137);
Integer i4 = new Integer(137);
System.out.println(i3 == i4);//false
Integer i5 = Integer.valueOf("3");
Integer i6 = Integer.valueOf("3");
System.out.println(i5 == i6);//true
Integer i7 = Integer.valueOf("137");
Integer i8 = Integer.valueOf("137");
System.out.println(i7 == i8);//false
Integer i9 = 3;
Integer i10 = 3;
System.out.println(i9 == i10);//true
Integer i11 = 137;
Integer i12 = 137;
System.out.println(i11 == i12);//false
```

对于基本数据类型，如果在一个字节内，（即：-128 ~ 127）之间，一旦被包装成Integer对象的时候，就会被放到一个缓冲池中，当下次又需要将这个整数包装成Integer对象的时候，则会首先查找缓冲池中有没有这个对象，有的换就直接取出来。小整数装箱出来的都是同一个对象。这个结论仅仅适用于自动装箱操作，如果显式的进行装箱（即使用new的方式），则不合适。由于较小整数使用频率较高，此种操作节省了内存空间，这种模式叫做：享元模式-->flyweight

# 补充1： #

简单通俗的讲，一个完整的Java程序运行过程会涉及以下内存区域：

寄存器：JVM内部虚拟寄存器，存取速度非常快，程序不可控制。

栈：保存局部变量的值，包括：1.用来保存基本数据类型的值；2.保存类的实例，即堆区对象的引用(指针)。也可以用来保存加载方法时的帧。

堆：用来存放动态产生的数据，比如new出来的对象。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。

常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。

全局代码区：保存所有的方法定义。

全局数据区：用来存放static定义的静态成员。

注：此文章部分内容来自互联网，具体出处不明。如不慎侵害的您的相关权益，请留言告知，本人将尽快删除相关内容。